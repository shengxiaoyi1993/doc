# class 

- 分类
  - 数据类：保存数据，类似于结构体
  - 业务类：
    - 单线程类：核心业务处理方法是否阻塞
    - 多线程类

- 声明周期（**四段式**）
  - OPEN:OPEN里面一般是分配内存、创建句柄等工作
  - CLOSE:CLOSE 是释放内存和销毁句柄
  - CONFIG :CONFIG 就是对行为方式进行配置
  - RUN:执行业务逻辑
  -  对于多线程业务类，会用 START/STOP替代 OPEN/CLOSE，在 START 中创建线程，在STOP 终止线程

- **数据保护**:类中所有数据都应该用PRIVATE 或 PROTECTED 修饰，而严禁用 PUBLIC 修饰，这就是所谓数据保护原则



- 编译器提供的方法 

  - 默认的构造函数：

    - Star orig;
    - Star array[6];都将需要默认构造函数

  - 复制构造函数：Star(const Star &)

    * 将新对象初始化为一个同类对象

    * 函数按值传递对象参数

    * 函数返回对象（而不是对象的引用）

    * 生成临时对象

  - 赋值运算符 =

    - post = pre; // copy assignment



- 注意事项

1）构造函数不能够被继承（使用），只有自己需要生成对象时被使用。继承的派生类构造函数，会调用基类的构造函数。

2）析构函数，在使用new动态生成成员变量是一定要显式定义析构函数；当基类中存在virtual或者pure virtual时，将析构函数也定义为virtual。

3）转换构造函数，如果你不希望出现隐式的类型转换，使用【explicit】声明函数，但仍然可以使用显式的强制转换。

例如：

explict string(const char *);

4）按值传递和按引用传递

我们知道，一般情况下在类设计中都是用按引用传递，按值传递会隐式的调用复制构造函数和析构函数，在返回大型类时极其影响效率。可以节省时间和内存！！

按引用传递的另外原因：在继承使用虚函数时，被定义接受基类引用的参数可以接受派生类的引用。

5）const的使用

尽可能的使用const，但要注意场合。确保const参数在传递过程中不会修改其属性（常量），【可以将非const传给const参数，但禁止将const传给非const】。



- 面向对象（oop）的设计原则
  - 1.单一职责原则（Single Resposibility Principle，SRP）
    - 高内聚、低耦合:减少模块间的联系，提高模块内的
  - 2.开放封闭原则（Open Closed Principle，OCP）
    - 扩展开放，修改关闭
    - 拓展一般用继承和多态。基类中定义的方法，子类中可以用同一方法进行调用
  - 3.里氏替换原则（Liskov Substituion Principle，LSP）
    - 使用父类的地方都能使用子类对象
    - 在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象
    - 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法
    - 子类中可以增加自己特有的方法
    - 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松
  - 4.依赖倒置原则（Dependecy Inversion Principle，DIP）
    - 针对接口编程
    - 具体而言就是高层模块不依赖于底层模块，二者都依赖于抽象；抽象不依赖于具体，具体依赖于抽象
  - 5.接口分离原则（Interface Segregation Principle，ISP）
    - 针对不同部分用专门接口，不用总接口，需要哪些接口就用哪些接口
    - 分离方法
      - 利用委托分离接口:函数对象
      - 利用多重继承分离接口
  - 6.迪米特法则（Law of Demeter，LOD）
    - 软件实体类，尽量不与其他实体类发生关系相互作用，对外都统一的暴露接口就行了



- 软件系统的设计
  //技术描述
  - 数据结构设计
  - 系统结构设计
    - 接口设计
    - 体系结构设计
  - 过程设计：结构成分转换成软件的过程性描述
  //管理描述
  - 概要设计：软件结构和组成成分的关系
  - 详细设计：模块内部的算法和数据结构，模块程序过程


- 设计方法
  - 结构化设计方法(sd)
  - 面向数据结构的设计方法(jsd)
  - 面向对象的设计方法（ood）

- 模块设计
  - 属性
    - 功能
    - 逻辑
    - 状态
  - 特性
    
    - 低耦合
      - 非直接耦合：
      - 数据耦合：通过简单数据参数交互，非外部数据、控制参数、公共数据结构
      - 标记耦合：通过参数表（数据结构的子结构）传递信息
      - 控制耦合：通过控制信息选择另一模块的功能
      - 外部耦合：都访问同一全局简单变量
      - 公共耦合：都访问同一公共数据环境（全局数据结构、共享通信区，内存覆盖区）
        - 松散公共耦合：只读
        - 紧密公共耦合：可读写
      - 内容耦合
        - 直接访问内部数据结构
        - 不通过正常入口进入模块
        - 代码重迭（汇编语言）
        - 模块有多个入口
    - 高内聚
      - 信息内聚：功能都是基于同一个数据结构 
      - 通信内聚：各功能使用的输入数据与输出数据相同
      - 过程内聚：循环、判断、计算等部分
      - 时间内聚：模块的各个功能执行与时间有关的功能，需要在一段时间内执行。如初始化模块和终止模块
      - 逻辑内聚
      - 巧合内聚
      
- 软件设计
  - 体系结构设计
  - 用户界面设计
  - 数据库设计
  - 模块设计
  - 数据结构和算法设计


- 分解软件系统的基本方法无外乎分层和分割
  - 关注点分离，面向方面，面向对象，面向接口，面向服务，依赖注入